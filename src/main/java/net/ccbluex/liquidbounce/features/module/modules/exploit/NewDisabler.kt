package net.ccbluex.liquidbounce.features.module.modules.exploit

import net.ccbluex.liquidbounce.LiquidBounce
import net.ccbluex.liquidbounce.event.*
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.features.module.ModuleCategory
import net.ccbluex.liquidbounce.features.module.ModuleInfo
import net.ccbluex.liquidbounce.features.module.ModuleManager
import net.ccbluex.liquidbounce.features.module.modules.combat.KillAura
import net.ccbluex.liquidbounce.features.module.modules.movement.Flight
import net.ccbluex.liquidbounce.features.module.modules.movement.Speed
import net.ccbluex.liquidbounce.features.module.modules.world.Scaffold
import net.ccbluex.liquidbounce.utils.MinecraftInstance
import net.ccbluex.liquidbounce.utils.MovementUtils
import net.ccbluex.liquidbounce.utils.PacketUtils
import net.ccbluex.liquidbounce.utils.PosLookInstance
import net.ccbluex.liquidbounce.utils.timer.MSTimer
import net.ccbluex.liquidbounce.value.BoolValue
import net.ccbluex.liquidbounce.value.ListValue
import net.minecraft.network.Packet
import net.minecraft.network.play.INetHandlerPlayServer
import net.minecraft.network.play.client.*
import net.minecraft.util.BlockPos
import net.minecraft.util.EnumFacing
import java.util.*
import java.util.concurrent.LinkedBlockingQueue

@ModuleInfo(name = "Disabler", description = "Disable some anticheats' checks.", category = ModuleCategory.EXPLOIT)
class NewDisabler : Module() {
    val modeValue = ListValue("Mode",
            arrayOf(
                    "VulcanStrafe"
            ), "VulcanStrafe")

    private val linkedQueue: Queue<Packet<*>> = LinkedBlockingQueue()
    private val debugValue = BoolValue("Debug", false)
    private var rotatingSpeed = 0F
    private val keepAlives = arrayListOf<C00PacketKeepAlive>()
    private val transactions = arrayListOf<C0FPacketConfirmTransaction>()
    private val packetQueue = LinkedList<C0FPacketConfirmTransaction>()
    private val anotherQueue = LinkedList<C00PacketKeepAlive>()
    private val playerQueue = LinkedList<C03PacketPlayer>()
    private val packetBus = hashMapOf<Long, Packet<INetHandlerPlayServer>>()
    private val queueBus = LinkedList<Packet<INetHandlerPlayServer>>()
    private val packetBuffer = LinkedList<Packet<INetHandlerPlayServer>>()
    private val posLookInstance = PosLookInstance()
    private val msTimer = MSTimer()
    private val wdTimer = MSTimer()
    private val benTimer = MSTimer()
    private val pulseTimer = MSTimer()
    private var disableLogger = false
    private var alrSendY = false
    private var alrSprint = false
    private var expectedSetback = false
    private var sendDelay = 0
    private var shouldActive = false
    private var benHittingLean = false
    private var transCount = 0
    private var counter = 0
    private var canModify = false
    var shouldModifyRotation = false
    private var lastTick = 0
    private var s08count = 0
    private var ticking = 0
    private var lastYaw = 0F
    private var lastUid = 0
    private var currentTrans = 0
    private var currentDelay = 5000
    private var currentBuffer = 4
    private var currentDec = -1
    private val lagTimer = MSTimer()
    private val decTimer = MSTimer()
    private var runReset = false

    override fun onEnable() {
        packetBuffer.clear()
        keepAlives.clear()
        transactions.clear()
        packetQueue.clear()
        anotherQueue.clear()
        playerQueue.clear()
        packetBus.clear()
        queueBus.clear()

        s08count = 0

        pulseTimer.reset()
        msTimer.reset()
        wdTimer.reset()
        benTimer.reset()
        canModify = false
        expectedSetback = false
        shouldActive = false
        alrSendY = false
        alrSprint = false
        transCount = 0
        lastTick = 0
        ticking = 0

        lastUid = 0
        posLookInstance.reset()

        shouldModifyRotation = false
        benHittingLean = false

        rotatingSpeed = 0F
    }

    override fun onDisable() {
        val scaffold = LiquidBounce.moduleManager.getModule(Scaffold::class.java)

        if (!MinecraftInstance.mc.thePlayer.isSneaking && !scaffold!!.state) MovementUtils.strafe(0.2f)

        keepAlives.forEach {
            PacketUtils.sendPacketNoEvent(it)
        }
        transactions.forEach {
            PacketUtils.sendPacketNoEvent(it)
        }

        packetBuffer.clear()
        keepAlives.clear()
        transactions.clear()
        packetQueue.clear()
        anotherQueue.clear()
        packetBus.clear()
        queueBus.clear()

        msTimer.reset()

        MinecraftInstance.mc.thePlayer.motionY = 0.0
        MovementUtils.strafe(0F)
        MinecraftInstance.mc.timer.timerSpeed = 1F

        shouldModifyRotation = false
    }

    @EventTarget
    fun onWorld(event: WorldEvent) {
        packetBuffer.clear()
        transactions.clear()
        keepAlives.clear()
        packetQueue.clear()
        anotherQueue.clear()
        playerQueue.clear()
        packetBus.clear()
        queueBus.clear()
        canModify = false

        s08count = 0

        msTimer.reset()
        wdTimer.reset()
        benTimer.reset()
        expectedSetback = false
        shouldActive = false
        alrSendY = false
        alrSprint = false
        benHittingLean = false
        transCount = 0
        counter = 0
        lastTick = 0
        ticking = 0
        lastUid = 0
        posLookInstance.reset()

        rotatingSpeed = 0F
    }

    @EventTarget
    fun onPacket(event: PacketEvent) {
        val packet = event.packet
        if(LiquidBounce.moduleManager.getModule("Speed")?.state == true){
            if (modeValue.get().equals("vulcanstrafe", true)) {
                if (MinecraftInstance.mc.thePlayer.ticksExisted % 2 == 0) {
                    if (packet is C03PacketPlayer.C04PacketPlayerPosition || packet is C03PacketPlayer.C06PacketPlayerPosLook ||
                            packet is C08PacketPlayerBlockPlacement ||
                            packet is C0APacketAnimation ||
                            packet is C0BPacketEntityAction || packet is C02PacketUseEntity
                    ) {
                        event.cancelEvent()
                        packetBuffer.add(packet as Packet<INetHandlerPlayServer>)
                    }
                }
            }
        }
    }

    @EventTarget(priority = 2)
    fun onMotion(event: MotionEvent) {
        val killAura = LiquidBounce.moduleManager.getModule(KillAura::class.java)!!
        val speed = LiquidBounce.moduleManager.getModule(Speed::class.java)!!
        val fly = LiquidBounce.moduleManager.getModule(Flight::class.java)!!

        if (event.eventState == EventState.PRE)
            shouldModifyRotation = false

    }

    @EventTarget
    fun onUpdate(event: UpdateEvent) {
        if(LiquidBounce.moduleManager.getModule("Speed")?.state == true) {
            if (modeValue.get().equals("vulcanstrafe", true)) {
                if (MinecraftInstance.mc.thePlayer.ticksExisted % 5 == 0)
                    MinecraftInstance.mc.netHandler.addToSendQueue(
                            C07PacketPlayerDigging(
                                    C07PacketPlayerDigging.Action.STOP_DESTROY_BLOCK,
                                    BlockPos(-1, -1, -1),
                                    EnumFacing.UP
                            )
                    )
            }
        }
    }
}